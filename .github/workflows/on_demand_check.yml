name: On-Demand ARB Checker

on:
  issues:
    types: [opened, edited]
  workflow_dispatch:
    inputs:
      firmware_url:
        description: 'Direct URL to Firmware .zip'
        required: true

concurrency:
  group: check-arb-${{ github.event.issue.number || github.run_id }}
  cancel-in-progress: true

jobs:
  check-firmware:
    # Trigger if (manual) OR (issue title starts with [CHECK])
    if: github.event_name == 'workflow_dispatch' || startsWith(github.event.issue.title, '[CHECK]') || contains(github.event.issue.labels.*.name, 'checker')
    runs-on: ubuntu-latest
    permissions:
      issues: write

    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Determine URL & Mode
        id: setup
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "mode=manual" >> $GITHUB_OUTPUT
            echo "url=${{ inputs.firmware_url }}" >> $GITHUB_OUTPUT
            echo "URL from Manual Input: ${{ inputs.firmware_url }}"
          else
            echo "mode=issue" >> $GITHUB_OUTPUT
            # Extract URL from Issue Body
            # Create temp script to handle extraction safely
            # Use sed to strip leading whitespace so we can indent in YAML
            cat << 'EOF' | sed 's/^[[:space:]]*//' > extract_url.py
            import re, os
            body = os.environ.get('ISSUE_BODY', '')
            links = re.findall(r'(https?://[^\s]+\.zip(?:[^\s"\'\(\)\[\]]*)?)', body)
            if links: print(links[0])
          EOF
            URL=$(ISSUE_BODY="${{ github.event.issue.body }}" python3 extract_url.py)
            rm extract_url.py
            echo "url=$URL" >> $GITHUB_OUTPUT
          fi

      - name: Handle Missing URL (Issue)
        if: steps.setup.outputs.mode == 'issue' && steps.setup.outputs.url == ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue comment ${{ github.event.issue.number }} --body "‚ùå **Analysis Failed**
          
          No valid firmware URL found in the issue description. 
          Please ensure your link ends with \`.zip\` and is publicly accessible.
          
          *Closing this request.*"
          
          gh issue close ${{ github.event.issue.number }} --reason "not_planned"

      - name: Initialize Issue (Label & Comment)
        id: init_issue
        if: steps.setup.outputs.mode == 'issue' && steps.setup.outputs.url != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # 1. Add Label
          gh issue edit ${{ github.event.issue.number }} --add-label "checker"
          
          # 2. Fast Response (Before Tools)
          COMMENT_BODY="ü§ñ **Request Received!**\n\n- [ ] Setting up tools...\n- [ ] Downloading firmware...\n- [ ] Analyzing ARB index...\n\n**URL**: \`${{ steps.setup.outputs.url }}\`"
          # Use gh api to create comment and get its ID
          COMMENT_ID=$(gh api -X POST /repos/${{ github.repository }}/issues/${{ github.event.issue.number }}/comments -f body="$COMMENT_BODY" --jq '.id')
          echo "comment_id=$COMMENT_ID" >> $GITHUB_OUTPUT

      - name: Update Progress (Setup)
        if: steps.setup.outputs.mode == 'issue' && steps.setup.outputs.url != '' && success()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh api -X PATCH "/repos/${{ github.repository }}/issues/comments/${{ steps.init_issue.outputs.comment_id }}" -f body=$'ü§ñ **Processing...**\n\n- [x] Setting up tools...\n- [/] Downloading firmware...\n- [ ] Analyzing ARB index...\n\n**URL**: `${{ steps.setup.outputs.url }}`'

      - name: Install dependencies & Setup Tools
        if: steps.setup.outputs.url != ''
        run: |
          sudo apt-get update
          sudo apt-get install -y aria2 unzip curl python3-pip
          pip3 install requests beautifulsoup4 --break-system-packages || pip3 install requests beautifulsoup4
          mkdir -p tools
          curl -L -o tools/arbextract https://github.com/koaaN/arbextract/releases/download/1.0/arbextract-x86_64-linux
          chmod +x tools/arbextract
          curl -L -o otaripper.tar.gz https://github.com/syedinsaf/otaripper/releases/download/v2.1.1/otaripper-2.1.1-linux-static-x86_64.tar.gz
          tar -xzvf otaripper.tar.gz
          mv otaripper tools/otaripper || find . -name "otaripper" -type f -exec mv {} tools/otaripper \;
          chmod +x tools/otaripper
          curl -L -o pdg.tar.gz https://github.com/ssut/payload-dumper-go/releases/download/1.2.2/payload-dumper-go_1.2.2_linux_amd64.tar.gz
          tar -xzvf pdg.tar.gz
          mv payload-dumper-go tools/payload-dumper-go || find . -name "payload-dumper-go" -type f -exec mv {} tools/payload-dumper-go \;
          chmod +x tools/payload-dumper-go

      - name: Download Firmware
        if: steps.setup.outputs.url != ''
        run: |
          aria2c -x16 -s16 -k1M -o firmware.zip "${{ steps.setup.outputs.url }}"

      - name: Update Progress (Analysing)
        if: steps.setup.outputs.mode == 'issue' && steps.setup.outputs.url != '' && success()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh api -X PATCH "/repos/${{ github.repository }}/issues/comments/${{ steps.init_issue.outputs.comment_id }}" -f body=$'ü§ñ **Processing...**\n\n- [x] Setting up tools...\n- [x] Downloading firmware...\n- [/] Analyzing ARB index...\n\n**URL**: `${{ steps.setup.outputs.url }}`'

      - name: Analyze Firmware
        id: analyze
        if: steps.setup.outputs.url != '' && hashFiles('firmware.zip') != ''
        run: |
          # This outputs result.json and also prints logs to stdout (visible in workflow logs)
          python3 analyze_firmware.py firmware.zip \
            --tools-dir tools \
            --output-dir extracted \
            --final-dir firmware_data \
            --json > result.json

      - name: Generate Final Report
        if: always() && steps.setup.outputs.url != ''
        shell: python
        env:
          ISSUE_USER: ${{ github.event.issue.user.login }}
          EVENT_NAME: ${{ github.event_name }}
        run: |
          import json, os
          
          # Default failure message
          output = "‚ùå **Analysis Failed**\nSomething went wrong. The partition `xbl_config` was not found or the link is invalid."
          
          if os.path.exists('result.json'):
              try:
                  with open('result.json', 'r') as f:
                      res = json.load(f)
                  
                  arb = res.get('arb_index', 'Unknown')
                  status = '‚úÖ **Safe to flash/roll back**' if arb == '0' else '‚ö†Ô∏è **Anti-Rollback Active!**'
                  
                  meta = res.get('ota_metadata', {})
                  device = meta.get('pre-device', 'Unknown')
                  product = meta.get('product_name', 'Unknown')
                  patch = meta.get('post-security-patch-level', meta.get('security_patch', 'Unknown'))
                  version = meta.get('version_name_show', meta.get('display-version', 'Unknown'))
                  build = meta.get('post-build', 'Unknown')
                  
                  # Get user handle or default for manual
                  user = os.environ.get('ISSUE_USER')
                  if not user or user == 'null': 
                      user = "Manual Trigger"

                  output = f"@{user}, here is your analysis!\n"
                  output += f"### üëë üéØ Analysis Result\n"
                  output += f"- **ARB Index**: `{arb}`\n"
                  output += f"- **Status**: {status}\n\n"
                  output += f"#### üì± Firmware Details\n"
                  output += f"- **Version**: `{version}`\n"
                  output += f"- **Product**: `{product}` (`{device}`)\n"
                  output += f"- **Security Patch**: `{patch}`\n"
                  output += f"- **Build ID**: `{build}`"
                  
                  # For manual runs, print nicely to stdout
                  print("-" * 40)
                  print("MANUAL ANALYSIS RESULT")
                  print("-" * 40)
                  print(f"ARB Index: {arb}")
                  print(f"Status: {status}")
                  print(f"Device: {product} ({device})")
                  print(f"Version: {version}")
                  print("-" * 40)

              except Exception as e:
                  print(f"Error parsing result: {e}")
          
          # Save as JSON payload for gh api (used if issue mode)
          payload = {"body": output}
          with open('payload.json', 'w') as f:
              json.dump(payload, f)

      - name: Post Final Result (Issue)
        if: steps.setup.outputs.mode == 'issue' && steps.setup.outputs.url != '' && always()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ -f payload.json ]; then
            gh api -X PATCH "/repos/${{ github.repository }}/issues/comments/${{ steps.init_issue.outputs.comment_id }}" --input payload.json
          fi

      - name: Wait before closing
        if: steps.setup.outputs.mode == 'issue' && steps.setup.outputs.url != '' && always()
        run: sleep 180

      - name: Close Issue
        if: steps.setup.outputs.mode == 'issue' && steps.setup.outputs.url != '' && always()
        run: |
          gh issue close ${{ github.event.issue.number }} --reason "completed"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup
        if: always()
        run: rm -f firmware.zip result.json
