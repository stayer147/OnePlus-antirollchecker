name: Check ARB

on:
  workflow_dispatch:
    inputs:
      force_recheck:
        description: 'Force recheck all firmwares even if already checked'
        required: false
        default: false
        type: boolean
  schedule:
    - cron: '0 0 * * *' # Run daily

jobs:
  setup-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4
      
      - name: Generate Matrix
        id: set-matrix
        run: python3 generate_matrix.py

  check-variant:
    needs: setup-matrix
    runs-on: ubuntu-latest
    continue-on-error: true
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.setup-matrix.outputs.matrix) }}
    
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y aria2 unzip curl python3-pip
          pip3 install requests beautifulsoup4 --break-system-packages || pip3 install requests beautifulsoup4

      - name: Setup Tools
        run: |
          mkdir -p tools
          
          # Setup arbextract
          curl -L -o tools/arbextract https://github.com/koaaN/arbextract/releases/download/1.0/arbextract-x86_64-linux
          chmod +x tools/arbextract
          
          # Setup otaripper
          curl -L -o otaripper.tar.gz https://github.com/syedinsaf/otaripper/releases/download/v2.1.1/otaripper-2.1.1-linux-static-x86_64.tar.gz
          tar -xzvf otaripper.tar.gz
          # The tar likely contains the binary 'otaripper' directly or in a folder.
          # Based on docs/standard behavior, let's assume binary is named 'otaripper'
          # We move it to tools/
          mv otaripper tools/otaripper || find . -name "otaripper" -type f -exec mv {} tools/otaripper \;
          chmod +x tools/otaripper
          
      - name: Get Firmware Details
        id: get_details
        run: |
          # Unified fetching logic using fetch_firmware.py
          # It handles OOS API priority and Springer fallback
          
          echo "Fetching details for ${{ matrix.device }} ${{ matrix.variant }}..."
          
          # Use --output file to avoid log contamination in stdout
          python3 fetch_firmware.py "${{ matrix.device }}" "${{ matrix.variant }}" --output fw_info.json
          
          if [ ! -f fw_info.json ]; then
             echo "Failed to fetch firmware details (no output file)"
             exit 1
          fi
          
          URL=$(python3 -c "import sys, json; print(json.load(open('fw_info.json'))['url'])")
          VERSION=$(python3 -c "import sys, json; print(json.load(open('fw_info.json'))['version'])")
          
          echo "Device: ${{ matrix.device_name }}"
          echo "Variant: ${{ matrix.variant }}"
          echo "Latest Firmware URL: $URL"
          echo "Latest Firmware Version: $VERSION"
          
          echo "url=$URL" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "device_short=${{ matrix.device_short }}" >> $GITHUB_OUTPUT

      - name: Restore ARB Cache
        id: cache-arb
        if: github.event.inputs.force_recheck != 'true'
        uses: actions/cache/restore@v4
        with:
          path: |
            arb_check_done.txt
            firmware_data/
          # Cache key includes device and variant to be separate
          key: arb-check-v7-${{ matrix.device }}-${{ matrix.variant }}-${{ steps.get_details.outputs.version }}

      - name: Download Firmware
        if: steps.cache-arb.outputs.cache-hit != 'true'
        run: |
          URL="${{ steps.get_details.outputs.url }}"
          VERSION="${{ steps.get_details.outputs.version }}"
          
          if [[ "$URL" != *".zip"* && "${{ matrix.variant }}" != "CN" ]]; then
            echo "Skipping non-direct download link: $URL"
            touch skip_check.txt
            exit 0
          fi

          echo "Downloading firmware with robust retry loop..."
          MAX_RETRIES=5
          RETRY_COUNT=0
          SUCCESS=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Attempting download (Try $((RETRY_COUNT+1))/$MAX_RETRIES)..."
            if aria2c -c -x16 -s16 -k1M -o firmware.zip "$URL"; then
              echo "Download successful!"
              SUCCESS=1
              break
            fi
            
            echo "Download failed. Refreshing URL..."
            RETRY_COUNT=$((RETRY_COUNT+1))
            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then break; fi
            
            python3 fetch_firmware.py "${{ matrix.device }}" "${{ matrix.variant }}" "$VERSION" --output fw_refresh.json
            if [ -f fw_refresh.json ]; then
               NEW_URL=$(python3 -c "import sys, json; print(json.load(open('fw_refresh.json'))['url'])")
               if [[ "$NEW_URL" != "" && "$NEW_URL" != "null" ]]; then
                  URL="$NEW_URL"
                  echo "Refreshed URL successfully."
               fi
            fi
            sleep 5
          done
          
          if [ $SUCCESS -eq 0 ]; then
             echo "Download failed after all attempts."
             touch skip_check.txt
          fi

      - name: Analyze Firmware (Check ARB)
        if: steps.cache-arb.outputs.cache-hit != 'true' && hashFiles('skip_check.txt') == ''
        run: |
          # Use the new standalone script
          # It extracts to 'extracted' (temp) and moves final file to 'firmware_data/xbl_config.img'
          python3 analyze_firmware.py firmware.zip \
            --tools-dir tools \
            --output-dir extracted \
            --final-dir firmware_data \
            --json > result.json
          
          # Inject extra metadata into result.json for update_history.py
          # (We could have passed these to analyze_firmware.py, but it's pure analysis)
          # Let's just use jq or python to merge? Or just pass arguments to update_history.py explicitly
          # Update: update_history.py accepts --json-file and missing args separate.
          # We need to make sure result.json has device_short, variant, version if we assume --json-file provides all.
          # But analyze_firmware.py only outputs ARB info.
          # So we will pass the rest as args.
          
          cat result.json

      - name: Update JSON History (Current Version)
        if: hashFiles('result.json') != ''
        run: |
          python3 update_history.py \
            "${{ steps.get_details.outputs.device_short }}" \
            "${{ matrix.variant }}" \
            "${{ steps.get_details.outputs.version }}" \
            --json-file result.json

      - name: Upload Result
        uses: actions/upload-artifact@v4
        with:
          name: result-${{ matrix.device }}-${{ matrix.variant }}
          path: result.json
      
      - name: Save ARB Cache
        if: steps.cache-arb.outputs.cache-hit != 'true' && hashFiles('firmware_data/xbl_config.img') != ''
        uses: actions/cache/save@v4
        with:
          path: |
            arb_check_done.txt
            firmware_data/
          key: arb-check-v7-${{ matrix.device }}-${{ matrix.variant }}-${{ steps.get_details.outputs.version }}

      - name: Upload JSON History
        uses: actions/upload-artifact@v4
        with:
          name: history-${{ matrix.device }}-${{ matrix.variant }}
          path: data/history/${{ steps.get_details.outputs.device_short }}_${{ matrix.variant }}.json

      - name: Cleanup
        if: always()
        run: rm -f firmware.zip

  update-readme:
    needs: check-variant
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          merge-multiple: false
      
      - name: Restore History & Generate README
        run: |
          mkdir -p data/history
          
          # Restore JSONs
          find artifacts -name 'history-*' -type d | while read dir; do
            JSON_FILE=$(find "$dir" -name '*.json' | head -n 1)
            if [ -f "$JSON_FILE" ]; then
              cp "$JSON_FILE" data/history/
            fi
          done
          
          # Install dependencies
          pip3 install jinja2

          # Generate
          python3 generate_readme.py
          python3 generate_site.py
          
      - name: Commit and Push
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add data/history/*.json README.md
          git commit -m "Update ARB history and README" || echo "No changes to commit"
          git push

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./page
